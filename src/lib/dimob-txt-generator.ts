import { prisma } from '@/lib/db'

interface DimobData {
  empresa: {
    cnpj: string
    nome: string
    endereco: string
    uf: string
    codigoMunicipio: string
    cpfResponsavel: string
  }
  contratos: Array<{
    sequencial: number
    locador: {
      documento: string
      nome: string
    }
    locatario: {
      documento: string
      nome: string
    }
    contrato: {
      numero: string
      data: string
    }
    valoresMensais: Array<{
      aluguel: number
      comissao: number
      imposto: number
    }>
    imovel: {
      tipo: string
      endereco: string
      cep: string
      codigoMunicipio: string
      uf: string
    }
  }>
}

/**
 * Gera arquivo DIMOB seguindo EXATAMENTE a especifica√ß√£o oficial da Basesoft
 */
export async function gerarArquivoDimobTxt(userId: string, ano: number, ownerId?: string): Promise<string> {
  console.log(`üìÑ [DIMOB OFICIAL] Gerando arquivo para ano ${ano}, usu√°rio ${userId}${ownerId ? `, propriet√°rio ${ownerId}` : ''}`)
  console.log(`üìÖ [DIMOB] Buscando pagamentos entre: ${new Date(ano, 0, 1).toISOString().slice(0, 10)} e ${new Date(ano, 11, 31).toISOString().slice(0, 10)}`)

  // Buscar dados da empresa declarante
  const empresa = await prisma.company.findFirst({
    where: {
      users: { some: { id: userId } }
    },
    include: {
      users: {
        where: { id: userId },
        select: { id: true, email: true }
      }
    }
  })

  if (!empresa) {
    throw new Error('Empresa n√£o encontrada para gerar DIMOB')
  }

  // Buscar contratos ativos com pagamentos do ano (filtrado por propriet√°rio se especificado)
  const whereCondition: any = {
    userId: userId,
    status: 'ACTIVE',
    payments: {
      some: {
        status: 'PAID',
        dueDate: {
          gte: new Date(ano, 0, 1),
          lte: new Date(ano, 11, 31)
        }
      }
    }
  }

  // Se ownerId foi especificado, filtrar apenas contratos deste propriet√°rio
  if (ownerId) {
    whereCondition.property = {
      ownerId: ownerId
    }
  }

  const contratos = await prisma.contract.findMany({
    where: whereCondition,
    include: {
      property: {
        include: { owner: true }
      },
      tenant: true,
      payments: {
        where: {
          status: 'PAID',
          dueDate: {
            gte: new Date(ano, 0, 1),
            lte: new Date(ano, 11, 31)
          }
        },
        orderBy: { dueDate: 'asc' }
      }
    }
  })

  console.log(`üìÑ [DIMOB] Encontrados ${contratos.length} contratos com pagamentos${ownerId ? ' para o propriet√°rio especificado' : ''}`)
  
  // Debug: mostrar quantos pagamentos TOTAIS existem para este propriet√°rio/ano (incluindo n√£o-PAID)
  if (contratos.length > 0) {
    const todosPayments = await prisma.payment.findMany({
      where: {
        contract: {
          userId: userId,
          property: ownerId ? { ownerId: ownerId } : undefined
        },
        dueDate: {
          gte: new Date(ano, 0, 1),
          lte: new Date(ano, 11, 31)
        }
      },
      select: {
        status: true,
        dueDate: true,
        amount: true
      },
      orderBy: { dueDate: 'asc' }
    })
    
    console.log(`üîç [DIMOB DEBUG] Total de pagamentos no ano ${ano}:`, todosPayments.length)
    const statusCount = todosPayments.reduce((acc, p) => {
      acc[p.status] = (acc[p.status] || 0) + 1
      return acc
    }, {} as Record<string, number>)
    console.log(`üìä [DIMOB DEBUG] Por status:`, statusCount)
    
    // Mostrar primeiros e √∫ltimos pagamentos
    if (todosPayments.length > 0) {
      console.log(`üìÖ [DIMOB DEBUG] Primeiro pagamento: ${todosPayments[0].dueDate.toISOString().slice(0, 10)} (${todosPayments[0].status})`)
      console.log(`üìÖ [DIMOB DEBUG] √öltimo pagamento: ${todosPayments[todosPayments.length-1].dueDate.toISOString().slice(0, 10)} (${todosPayments[todosPayments.length-1].status})`)
    }
  }

  if (contratos.length === 0) {
    const errorMsg = ownerId 
      ? 'Nenhum contrato com pagamentos encontrado para este propriet√°rio no ano especificado'
      : 'Nenhum contrato com pagamentos encontrado para o ano especificado'
    throw new Error(errorMsg)
  }

  // Validar dados obrigat√≥rios antes de gerar
  await validarDadosDimob(empresa, contratos)

  // Preparar dados estruturados
  const dimobData: DimobData = {
    empresa: {
      cnpj: limparDocumento(empresa.document, 14),
      nome: empresa.name || empresa.tradeName || 'EMPRESA',
      endereco: empresa.address || 'ENDERECO NAO INFORMADO',
      uf: empresa.state || 'DF',
      codigoMunicipio: '    ', // 4 espa√ßos em branco
      cpfResponsavel: empresa.responsibleCpf || '00000000000'
    },
    contratos: contratos.map((contrato, index) => {
      // Calcular valores mensais
      console.log(`üìä [DIMOB] Contrato ${index + 1}:`)
      console.log(`  üìÖ In√≠cio: ${contrato.startDate.toISOString().slice(0, 10)}`)
      console.log(`  üìä Taxa admin: ${contrato.administrationFeePercentage}%`)
      console.log(`  üí∞ Pagamentos encontrados: ${contrato.payments.length}`)
      
      // Debug: mostrar todos os pagamentos e suas datas
      contrato.payments.forEach((p, i) => {
        console.log(`  üí∞ Pagamento ${i + 1}: ${p.dueDate.toISOString().slice(0, 10)} - M√™s: ${p.dueDate.getMonth() + 1} - R$ ${p.amount}`)
      })
      
      const valoresMensais = Array.from({ length: 12 }, (_, mes) => {
        const pagamentosDoMes = contrato.payments.filter(p => p.dueDate.getMonth() === mes)
        const totalAluguel = pagamentosDoMes.reduce((acc, p) => acc + p.amount, 0)
        const totalComissao = totalAluguel * (contrato.administrationFeePercentage / 100)
        
        if (totalAluguel > 0) {
          console.log(`  üìÖ M√™s ${mes + 1}: ${pagamentosDoMes.length} pagamentos - Total: R$ ${totalAluguel} - Comiss√£o: R$ ${totalComissao.toFixed(2)}`)
        }
        
        return {
          aluguel: Math.round(totalAluguel * 100), // em centavos
          comissao: Math.round(totalComissao * 100), // em centavos
          imposto: 0 // normalmente zero para PF
        }
      })

      return {
        sequencial: index + 1,
        locador: {
          documento: formatarCpfCnpj(contrato.property.owner.document || ''),
          nome: contrato.property.owner.name.toUpperCase()
        },
        locatario: {
          documento: formatarCpfCnpjAlfa(contrato.tenant.document || ''),
          nome: contrato.tenant.name.toUpperCase()
        },
        contrato: {
          numero: contrato.id.slice(-6), // √∫ltimos 6 chars do ID
          data: formatarData(contrato.startDate)
        },
        valoresMensais,
        imovel: {
          tipo: contrato.property.dimobPropertyType || 'U',
          endereco: contrato.property.address?.toUpperCase() || 'ENDERECO NAO INFORMADO',
          cep: '72000000', // CEP v√°lido Bras√≠lia (faixa 70000-76999)
          codigoMunicipio: '9701', // C√≥digo oficial Bras√≠lia
          uf: contrato.property.state || 'DF'
        }
      }
    })
  }

  // Gerar conte√∫do do arquivo seguindo a especifica√ß√£o EXATA
  return gerarConteudoDimob(dimobData, ano)
}

/**
 * Gera o conte√∫do do arquivo seguindo a especifica√ß√£o oficial da Basesoft
 */
function gerarConteudoDimob(data: DimobData, ano: number): string {
  let conteudo = ''

  // === HEADER DA DECLARA√á√ÉO ===
  conteudo += 'DIMOB' // Sistema (5 posi√ß√µes)
  conteudo += ' '.repeat(369) // Reservado (369 espa√ßos)
  conteudo += '\r\n' // EOL

  // === R01 - DADOS INICIAIS ===
  conteudo += 'R01' // Tipo (3 posi√ß√µes)
  conteudo += data.empresa.cnpj // CNPJ declarante (14 posi√ß√µes)
  conteudo += ano.toString() // Ano-calend√°rio (4 posi√ß√µes)
  conteudo += '0' // Declara√ß√£o Retificadora (1 posi√ß√£o)
  conteudo += '0'.repeat(10) // N√∫mero do Recibo (10 posi√ß√µes)
  conteudo += '0' // Situa√ß√£o Especial (1 posi√ß√£o)
  conteudo += '0'.repeat(8) // Data evento (8 posi√ß√µes)
  conteudo += '00' // C√≥digo situa√ß√£o (2 posi√ß√µes)
  conteudo += data.empresa.nome.padEnd(60, ' ').slice(0, 60) // Nome Empresarial (60 posi√ß√µes)
  conteudo += limparDocumento(data.empresa.cpfResponsavel, 11) // CPF Respons√°vel (11 posi√ß√µes)
  conteudo += data.empresa.endereco.padEnd(120, ' ').slice(0, 120) // Endere√ßo (120 posi√ß√µes)
  conteudo += data.empresa.uf.padEnd(2, ' ').slice(0, 2) // UF (2 posi√ß√µes)
  conteudo += '9701' // C√≥digo Munic√≠pio Bras√≠lia (posi√ß√µes 237-240)
  conteudo += ' '.repeat(20) // Reservado (20 posi√ß√µes)
  conteudo += ' '.repeat(10) // Reservado (10 posi√ß√µes)
  
  // Validar tamanho R01 (deve ter 272 chars sem EOL)
  const r01Length = conteudo.split('\r\n')[1].length
  console.log(`üìè [DIMOB] Tamanho R01: ${r01Length} chars (deve ser 272)`)
  if (r01Length !== 272) {
    console.error(`‚ùå [DIMOB] R01 com tamanho incorreto: ${r01Length}, esperado: 272`)
  }
  
  conteudo += '\r\n' // EOL

  // === R02 - LOCA√á√ïES (uma para cada contrato) ===
  data.contratos.forEach(contrato => {
    conteudo += 'R02' // Tipo (3 posi√ß√µes)
    conteudo += data.empresa.cnpj // CNPJ declarante (14 posi√ß√µes)
    conteudo += ano.toString() // Ano-calend√°rio (4 posi√ß√µes)
    conteudo += contrato.sequencial.toString().padStart(7, '0') // Sequencial (7 posi√ß√µes)
    conteudo += contrato.locador.documento // CPF/CNPJ Locador (14 posi√ß√µes)
    conteudo += contrato.locador.nome.padEnd(60, ' ').slice(0, 60) // Nome Locador (60 posi√ß√µes)
    conteudo += contrato.locatario.documento // CPF/CNPJ Locat√°rio (14 posi√ß√µes)
    conteudo += contrato.locatario.nome.padEnd(60, ' ').slice(0, 60) // Nome Locat√°rio (60 posi√ß√µes)
    conteudo += contrato.contrato.numero.padEnd(6, ' ').slice(0, 6) // N√∫mero Contrato (6 posi√ß√µes)
    conteudo += contrato.contrato.data // Data Contrato (8 posi√ß√µes)
    
    // 36 campos de valores (12 meses √ó 3 valores = 36 campos de 14 posi√ß√µes cada)
    contrato.valoresMensais.forEach(mes => {
      conteudo += formatarValorR$(mes.aluguel) // Aluguel (14 posi√ß√µes)
      conteudo += formatarValorR$(mes.comissao) // Comiss√£o (14 posi√ß√µes)
      conteudo += formatarValorR$(mes.imposto) // Imposto (14 posi√ß√µes)
    })
    
    conteudo += contrato.imovel.tipo // Tipo Im√≥vel (1 posi√ß√£o)
    conteudo += contrato.imovel.endereco.padEnd(60, ' ').slice(0, 60) // Endere√ßo (60 posi√ß√µes)
    conteudo += contrato.imovel.cep.padStart(8, '0').slice(0, 8) // CEP (8 posi√ß√µes)
    conteudo += '9701' // C√≥digo Munic√≠pio Bras√≠lia (posi√ß√µes 764-767)
    conteudo += ' '.repeat(20) // Reservado (20 posi√ß√µes)
    conteudo += contrato.imovel.uf.padEnd(2, ' ').slice(0, 2) // UF (2 posi√ß√µes)
    conteudo += ' '.repeat(10) // Reservado (10 posi√ß√µes)
    conteudo += '\r\n' // EOL
  })

  // === T9 - TRAILER ===
  conteudo += 'T9' // Tipo (2 posi√ß√µes)
  conteudo += ' '.repeat(100) // Reservado (100 espa√ßos)
  conteudo += '\r\n' // EOL

  console.log(`üìÑ [DIMOB] Arquivo gerado: ${conteudo.split('\r\n').length - 1} linhas, ${data.contratos.length} contratos`)
  return conteudo
}

/**
 * Formatar valor no padr√£o R$ do DIMOB (14 posi√ß√µes, centavos, zeros √† esquerda)
 */
function formatarValorR$(centavos: number): string {
  return centavos.toString().padStart(14, '0')
}

/**
 * Formatar CPF/CNPJ para 14 posi√ß√µes (CNPJ completo ou CPF alinhado √† esquerda)
 */
function formatarCpfCnpj(documento: string): string {
  const limpo = documento.replace(/\D/g, '')
  if (limpo.length === 14) {
    return limpo // CNPJ
  } else {
    return limpo.padStart(11, '0').padEnd(14, ' ') // CPF alinhado √† esquerda
  }
}

/**
 * Formatar CPF/CNPJ alfanum√©rico para locat√°rio (pode aceitar NDP)
 */
function formatarCpfCnpjAlfa(documento: string): string {
  const limpo = documento.replace(/\D/g, '')
  if (limpo.length === 14) {
    return limpo // CNPJ
  } else {
    return limpo.padStart(11, '0').padEnd(14, ' ') // CPF alinhado √† esquerda
  }
}

/**
 * Limpar documento removendo caracteres n√£o num√©ricos
 */
function limparDocumento(documento: string, tamanho: number): string {
  return documento.replace(/\D/g, '').padStart(tamanho, '0')
}

/**
 * Formatar data no padr√£o DDMMAAAA
 */
function formatarData(data: Date): string {
  const dia = data.getDate().toString().padStart(2, '0')
  const mes = (data.getMonth() + 1).toString().padStart(2, '0')
  const ano = data.getFullYear().toString()
  return `${dia}${mes}${ano}`
}

/**
 * Extrair CEP do endere√ßo (busca padr√£o 00000-000)
 */
function extrairCep(endereco: string): string {
  const match = endereco.match(/\d{5}-?\d{3}/)
  if (match) {
    return match[0].replace('-', '').padStart(8, '0')
  }
  return '72000000' // CEP v√°lido Bras√≠lia
}

/**
 * Obter c√≥digo do munic√≠pio (simplificado - usar tabela IBGE real)
 */
function obterCodigoMunicipio(cidade: string): string {
  // C√≥digos DIMOB (4 d√≠gitos) - usar tabela oficial
  const codigos: { [key: string]: string } = {
    'BRASILIA': '1001', // Tentativa c√≥digo Bras√≠lia 
    'SAO PAULO': '3101', // S√£o Paulo
    'RIO DE JANEIRO': '3301', // Rio de Janeiro
    'BELO HORIZONTE': '3106', // Belo Horizonte
    'SALVADOR': '2901', // Salvador
    'FORTALEZA': '2301', // Fortaleza
    'RECIFE': '2601', // Recife
    'PORTO ALEGRE': '4301', // Porto Alegre
    'CURITIBA': '4101' // Curitiba
  }
  
  return codigos[cidade.toUpperCase()] || '0000' // Default: c√≥digo vazio
}

/**
 * Validar se todos os campos obrigat√≥rios para DIMOB est√£o preenchidos
 */
async function validarDadosDimob(empresa: any, contratos: any[]): Promise<void> {
  const erros: string[] = []

  // Validar dados da empresa
  if (!empresa.responsibleCpf) {
    erros.push('‚ùå CPF do respons√°vel da empresa n√£o informado (obrigat√≥rio DIMOB)')
  }
  if (!empresa.municipalityCode) {
    erros.push('‚ùå C√≥digo do munic√≠pio da empresa n√£o informado (obrigat√≥rio DIMOB)')
  }
  if (!empresa.document || empresa.document.length < 14) {
    erros.push('‚ùå CNPJ da empresa inv√°lido (obrigat√≥rio DIMOB)')
  }

  // Validar dados dos contratos
  contratos.forEach((contrato, index) => {
    const numero = index + 1

    // Validar propriet√°rio
    if (!contrato.property.owner.document) {
      erros.push(`‚ùå Contrato ${numero}: CPF/CNPJ do propriet√°rio n√£o informado`)
    }
    if (!contrato.property.owner.name) {
      erros.push(`‚ùå Contrato ${numero}: Nome do propriet√°rio n√£o informado`)
    }

    // Validar inquilino
    if (!contrato.tenant.document) {
      erros.push(`‚ùå Contrato ${numero}: CPF/CNPJ do inquilino n√£o informado`)
    }
    if (!contrato.tenant.name) {
      erros.push(`‚ùå Contrato ${numero}: Nome do inquilino n√£o informado`)
    }

    // Validar im√≥vel
    if (!contrato.property.dimobPropertyType) {
      erros.push(`‚ùå Contrato ${numero}: Tipo do im√≥vel (Urbano/Rural) n√£o informado`)
    }
    if (!contrato.property.municipalityCode) {
      erros.push(`‚ùå Contrato ${numero}: C√≥digo do munic√≠pio do im√≥vel n√£o informado`)
    }
    if (!contrato.property.extractedCep && !extrairCep(contrato.property.address)) {
      erros.push(`‚ùå Contrato ${numero}: CEP do im√≥vel n√£o pode ser extra√≠do do endere√ßo`)
    }

    // Validar se tem pagamentos
    if (contrato.payments.length === 0) {
      erros.push(`‚ùå Contrato ${numero}: Nenhum pagamento encontrado`)
    }
  })

  // Se houver erros, lan√ßar exce√ß√£o com todos os problemas
  if (erros.length > 0) {
    const mensagem = [
      'üö® DADOS OBRIGAT√ìRIOS FALTANDO PARA DIMOB:',
      '',
      ...erros,
      '',
      'üí° SOLU√á√ÉO: Complete os dados faltantes antes de gerar o arquivo DIMOB.',
      '   Acesse as configura√ß√µes da empresa e cadastro dos im√≥veis para preencher os campos obrigat√≥rios.'
    ].join('\n')
    
    throw new Error(mensagem)
  }
}