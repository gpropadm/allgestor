import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';

export async function POST(request: NextRequest) {
  try {
    console.log('üöÄ Iniciando gera√ß√£o autom√°tica de boletos...');
    
    const today = new Date();
    const currentDay = today.getDate();
    
    console.log(`üìÖ Data atual: ${today.toLocaleDateString('pt-BR')} - Dia: ${currentDay}`);

    // Buscar TODOS os contratos com gera√ß√£o autom√°tica ativada
    // Executa sempre no dia 1¬∫ para gerar boletos do pr√≥ximo m√™s
    const contractsToProcess = await prisma.contract.findMany({
      where: {
        autoGenerateBoletos: true,
        status: 'ACTIVE'
      },
      include: {
        tenant: true,
        property: {
          include: {
            owner: {
              include: {
                bankAccounts: {
                  where: { validated: true },
                  take: 1
                }
              }
            }
          }
        },
        company: true,
        payments: {
          where: {
            dueDate: {
              gte: new Date(today.getFullYear(), today.getMonth(), 1), // In√≠cio do m√™s atual
              lt: new Date(today.getFullYear(), today.getMonth() + 1, 1), // In√≠cio do pr√≥ximo m√™s
            }
          }
        }
      }
    });

    console.log(`üìã Encontrados ${contractsToProcess.length} contratos para processar`);

    const results = [];

    for (const contract of contractsToProcess) {
      try {
        console.log(`üîç Processando contrato: ${contract.id} - ${contract.tenant.name}`);

        // Verificar se j√° existe boleto para o pr√≥ximo m√™s
        // Vencimento: pr√≥ximo m√™s, no dia configurado do contrato
        const nextMonth = new Date(today.getFullYear(), today.getMonth() + 1, contract.autoGenerateDay || 10);
        
        const existingPayment = await prisma.payment.findFirst({
          where: {
            contractId: contract.id,
            dueDate: {
              gte: new Date(nextMonth.getFullYear(), nextMonth.getMonth(), 1),
              lt: new Date(nextMonth.getFullYear(), nextMonth.getMonth() + 1, 1),
            }
          }
        });

        if (existingPayment) {
          console.log(`‚ö†Ô∏è Boleto j√° existe para ${nextMonth.toLocaleDateString('pt-BR')} - Pulando`);
          results.push({
            contractId: contract.id,
            tenant: contract.tenant.name,
            status: 'SKIPPED',
            reason: 'Boleto j√° existe para o pr√≥ximo m√™s'
          });
          continue;
        }

        // Verificar se propriet√°rio tem conta ASAAS configurada
        const owner = contract.property.owner;
        const bankAccount = owner.bankAccounts[0];

        if (!bankAccount || !bankAccount.asaasWalletId) {
          console.log(`‚ùå Propriet√°rio sem conta ASAAS: ${owner.name}`);
          results.push({
            contractId: contract.id,
            tenant: contract.tenant.name,
            status: 'ERROR',
            reason: 'Propriet√°rio sem conta ASAAS configurada'
          });
          continue;
        }

        // Gerar boleto usando a mesma l√≥gica da API de boletos mensais
        const boletoData = {
          customer: {
            name: contract.tenant.name,
            email: contract.tenant.email,
            phone: contract.tenant.phone,
            cpfCnpj: contract.tenant.document,
            address: contract.tenant.address,
            addressNumber: "S/N",
            complement: "",
            province: contract.tenant.city,
            city: contract.tenant.city,
            state: contract.tenant.state,
            postalCode: contract.tenant.zipCode
          },
          billingType: "BOLETO",
          value: contract.rentAmount,
          dueDate: nextMonth.toISOString().split('T')[0],
          description: `Aluguel ${contract.property.title} - ${nextMonth.toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' })}`,
          split: [
            {
              walletId: bankAccount.asaasWalletId,
              fixedValue: contract.rentAmount * (1 - contract.administrationFeePercentage / 100)
            }
          ]
        };

        // Aqui voc√™ chamaria a API do ASAAS para criar o boleto
        // Por enquanto, vamos simular criando o registro no banco
        const payment = await prisma.payment.create({
          data: {
            contractId: contract.id,
            amount: contract.rentAmount,
            dueDate: nextMonth,
            status: 'PENDING',
            paymentMethod: 'BOLETO',
            ownerAmount: contract.rentAmount * (1 - contract.administrationFeePercentage / 100),
            companyAmount: contract.rentAmount * (contract.administrationFeePercentage / 100),
            splitStatus: 'PENDING',
            // asaasPaymentId: response.id, // Seria preenchido com resposta real do ASAAS
            // boletoUrl: response.bankSlipUrl,
          }
        });

        console.log(`‚úÖ Boleto gerado automaticamente: ${payment.id}`);
        
        results.push({
          contractId: contract.id,
          tenant: contract.tenant.name,
          paymentId: payment.id,
          amount: contract.rentAmount,
          dueDate: nextMonth.toLocaleDateString('pt-BR'),
          status: 'SUCCESS'
        });

      } catch (contractError) {
        console.error(`‚ùå Erro ao processar contrato ${contract.id}:`, contractError);
        results.push({
          contractId: contract.id,
          tenant: contract.tenant?.name || 'Desconhecido',
          status: 'ERROR',
          reason: contractError instanceof Error ? contractError.message : 'Erro desconhecido'
        });
      }
    }

    const successful = results.filter(r => r.status === 'SUCCESS').length;
    const skipped = results.filter(r => r.status === 'SKIPPED').length;
    const errors = results.filter(r => r.status === 'ERROR').length;

    console.log(`üéØ Resumo da execu√ß√£o:`, {
      total: results.length,
      successful,
      skipped,
      errors
    });

    return NextResponse.json({
      success: true,
      message: `Processamento conclu√≠do: ${successful} gerados, ${skipped} pulados, ${errors} erros`,
      summary: {
        total: results.length,
        successful,
        skipped,
        errors
      },
      results
    });

  } catch (error) {
    console.error('‚ùå Erro na gera√ß√£o autom√°tica de boletos:', error);
    return NextResponse.json(
      { 
        error: 'Erro interno do servidor',
        details: error instanceof Error ? error.message : 'Erro desconhecido'
      },
      { status: 500 }
    );
  }
}

// GET para testar manualmente
export async function GET() {
  console.log('üß™ Teste manual da gera√ß√£o autom√°tica de boletos');
  return POST(new NextRequest('http://localhost/test'));
}